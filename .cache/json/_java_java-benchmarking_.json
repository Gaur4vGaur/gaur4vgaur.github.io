{"data":{"markdownRemark":{"id":"21656a9c-ee90-50b5-95c4-e66ab171cf72","excerpt":"Introduction Optimisation of code is an endless struggle. It is often even hard to produce meaningful metrics using jvm as it is an adaptive virtual machineâ€¦","html":"<h3>Introduction</h3>\n<p>Optimisation of code is an endless struggle. It is often even hard to produce meaningful metrics using jvm as it is an adaptive virtual machine. The article is</p>\n<ul>\n<li>a brief introduction to microbenchmarking,</li>\n<li>when to consider it,</li>\n<li>pitfalls to avoid, and finally,</li>\n<li>JMH framework to make benchmarking simple.</li>\n</ul>\n<h3>What is a microbenchmark</h3>\n<p>A microbenchmark is an attempt to measure the performance of a small unit of code. The tests are usually in the sub-millisecond range. The test can help determine how the code is going to behave when put into production. It can act as a guide to a better implementation.</p>\n<h3>Why microbenchmark</h3>\n<p>Profiling the whole app in a production or production-like environment is difficult. Profiling cannot pinpoint a specific piece of code. Moreover, it also counts external factors such as logging. Yet, profiling does produce realistic results.\nMicro-benchmarking focuses on a specific piece of code, removing everything else. But, you need to be careful of the results produced by benchmarking, as these are somewhat artificial.</p>\n<p>Why should I benchmark then?\nUsually, it should be the job of JVM to optimize the code. As a good practice, a developer should only focus on principles of clean coding. But it is always a good idea to review the code. You should consider asking can I break this loop early, or can I reduce the complexity of an algorithm?</p>\n<h3>When to consider microbenchmark</h3>\n<p>A developer should test an application in a way it is supposed to be used, with a similar kind of inputs. But, it might not be possible every time. For example, if you are trying to write an underlying support infrastructure for a variety of applications, or if you are producing a library. Thus, it is not possible to predict the range of inputs or to monitor and optimize the code for specific scenarios. In these scenarios, you can consider benchmarking.\nMicro benchmarking may still not provide definitive answers to problems you may face, but, it can point towards a better design. </p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"title":"Microbenchmarking with jvm","date":"April 02, 2021","subtitle":"A tour on Java Microbenchmark Harness and when to use it.","description":"A quick hands-on lesson to learn about JMH (Java Microbenchmark Harness) and when to use it.","tags":["Java","jvm","Java Microbenchmark Harness","Microbenchark","2021"]}}},"pageContext":{"slug":"/java/java-benchmarking/","previous":null,"next":{"frontmatter":{"title":"Sorting Lists of Objects in Scala","subtitle":"How to best sort lists in Scala.","description":"Learn how to set sort the lists in Scala. The blog talks about the usage of sortWith and sortBy along with coding examples","tags":["scala","functional programming","programming","tutorial","2019"]},"fields":{"slug":"/scala/sorting-lists-of-objects/"}}}}